% Find and analyse waves.
% The argument 'file' has to be a .mat file
% generated by findAllBursts

% 17/10/22 M Savage
% Adpated into scripts which use retinaWavesDefault and can be more easily
% run

function analyseWavesAPS_Stats(file, varargin)
%
% Parameters
%%%%%%%%%%%%
%
% plot the burst data in this time window:
% NEW: now also applies to movie and 36 waves plot
%showtime = [0 500];  % Fig 2
% showtime = [0 1400];  % Fig 3
%
% save the figures as .ps files (1 = yes)
% save_figs = 1;
%
% save the data as mywaves.mat file (1 = yes)
% save_data = 1;
%
% make a movie of the waves (1 = yes)
% show_movie = 1;
%
% do a raster plot of the wave bursts (1 = yes)
% show_raster = 1;
%
% show a panel of up to 36 successive waves (1 = yes)
% show36 = 1;
%
% smallest wave size to be shown in the 36-waves-plot
% minwavesize = 10;
%
% compute some wave statistics and show them
% do_stats = 1;
%
% plot cumulative histograms for sizes/durations? (stats only)
% cumhists = 1;
%
% how many monte carlo steps for p-value estimate?
% to get meningful results, this should be 1000 or so
% keep it small to reduce runtime
% 0 means the fits are not done at all
% monte_carlo_steps = 000;
%
% Wave detection parameters
%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% test if spike amplitudes satisfy quality criterium
% testForGaussian = 0;
%
% minimum number of spikes in a burst to include in analysis
% increasing this gets rid of noisy channels where spurious bursts were detected
% minNSpikes = 10;
%
% all the following parameters are now used for all data sets
% but may have to be adjusted
%
% the maximum variance allowed in the local centre of mass trajectory
% P4 (Fig 2): 12
% P9 (control_SpkTs_bursts.mat Fig 3): 5
% P12 (Phase_00_SpkTs_bursts.mat Fg 3): 5
% P5 (P05_AllPhases_Spikes_bursts.mat fig 3): 12
% searchradius = 40; % 10 default
%
% this is how many steps we look into the past to compute the centre of mass trajectories:
% a good default is ~20 or more, but it should be increased if small waves are not split properly
% nprev = 20;  % Fig 2 = 30
%
% minimum and maximum burst durations
% for this algorithm it is better to keep these short
% then it's possible to step through the waves in small steps...
% default values 2 (min) and 3 (max)
% minburstdur = 2;
% maxburstdur = 3;

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

h1 = figure();
h1.WindowState = 'maximized';
% clf
fs = [18 10]*1.3;
set(h1, 'PaperOrientation','portrait');
set(h1, 'PaperType','a4');
set(h1,'PaperUnits','centimeters');
set(h1,'Units','centimeters');
% p = get(h1,'Position');
% p = [p(1:2) fs];
% p(2) = p(2)-2; % HACK to fix figure screen position
set(h1,'PaperSize',fs)
set(h1,'PaperPosition',[0 0 fs])
% set(h1,'Position',p)
set(gcf, 'color', 'white');
set(gcf, 'InvertHardCopy', 'off');

colors=[repmat(hsv(12),600,1)];

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

fprintf(1,'loading data\n')
load(file)
%[path name ext v]=fileparts(file);
[path, name, ext] = fileparts(file);
filepathStruct = fullfile(path,name); % filename for save structure

% root filepath for saving burst files
rootFilepathInd = strfind(filepathStruct, '_Spk');

% checks if empty (usually if you use the waveEx file)
if isempty(rootFilepathInd)
    rootFilepathInd = strfind(filepathStruct, '_wave');
end

% get the root file name
rootFilepath = file(1:rootFilepathInd-1);

% load in previous data
bursts = waveEx.bursts;
ops = waveEx.ops;
ops = retinaWavesDefaults(ops);

% electrode num
elecs = bursts.testelecs;

xnplots = 4;
ynplots = 3;

% deal with varargin overrides
if ~isempty(varargin)
    varargin = reshape(varargin,2,  [])';

    for xx = 1:size(varargin, 1)
        if isstring(varargin{xx,2})
            eval(['ops.' varargin{xx,1} '=' varargin{xx,2} ';']);
        elseif isnumeric(varargin{xx,2}) && length(varargin{xx,2}) == 1
            eval(['ops.' varargin{xx,1} '=' num2str(varargin{xx,2}) ';']);
        elseif isnumeric(varargin{xx,2}) && length(varargin{xx,2}) > 1
            eval(['ops.' varargin{xx,1} '= [' num2str(varargin{xx,2}(:)') '];']);
        end
    end
end

% read and sort data
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

figure(1)

if ops.do_stats == 1
    % leave some space for stats plots
    subplot(ynplots,xnplots,[1 2 3 4])
else
    fs = [18 5]*1.3;
    p = get(h1,'Position');
    p = [p(1:2) fs];
    set(h1,'PaperSize',fs)
    set(h1,'PaperPosition',[0 0 fs])
    set(h1,'Position',p)
end

fprintf(1,'preparing data...')
pburstc = 1;
pburstn = 0;
eburstc = ones(max(elecs),1);
pburston = 0;
stop = 0;

if ops.testForGaussian == 1
    fprintf(1,'checking quality of each channel...\n')
    % filter out channels with signatures of bad spike detection
    telecs = [];
    for n=1:length(bursts.bursttime)
        tmp = spikes.peaks{n};
        [h,p] = kstest((tmp-mean(tmp))/std(tmp));
        %[h,p] = lillietest(tmp,0.05);
        if h == 0
            telecs = [telecs n];
        end
    end
else
    telecs = 1:length(bursts.burstsize); %elecs;
end

% remove channels with more than x Hz bursting (to exclude noisy channels)
maxt = max(cell2mat(cellfun(@max,bursts.bursttime,'UniformOutput',false)));
n = cellfun(@length,bursts.bursttime)/maxt*60;
telecs = find(n>0 & n<3); % 3Hz in Fig 2, 2Hz in Fig 3 P9+12

fprintf(1,'arranging data...\n')
% go thorugh all channels and prepare a few things
nt = repmat(NaN,max(elecs),1);
bdc = 0;
velecs = [];
lastburstend = 0;
for n = telecs
    % remove burst if it has not enough spikes
    tmp = find(bursts.burstsize{n}<ops.minNSpikes);
    if ~isempty(tmp)
        bursts.burstend{n}(tmp) = [];
        bursts.bursttime{n}(tmp) = [];
        bursts.burstsize{n}(tmp) = [];
    end
    if ~isempty(bursts.bursttime{n})
        burst_wavenumber{n} = zeros(length(bursts.burstend{n}),1);
        nt(n) = bursts.bursttime{n}(eburstc(n));
        for i=1:length(bursts.burstend{n})
            bdc = bdc + 1;
            bdur(bdc) = bursts.burstend{n}(i)-bursts.bursttime{n}(i);
            % the max burst duration is set to 6s here to avoid excessive
            % overlap, and the minimum to 2 so we don't lose waves:
            bursts.burstend{n}(i) = min(bursts.bursttime{n}(i)+ops.maxburstdur, bursts.burstend{n}(i));
            bursts.burstend{n}(i) = max(bursts.bursttime{n}(i)+ops.minburstdur, bursts.burstend{n}(i));
        end
        velecs = [velecs n];
        lastburstend = max(lastburstend, max(bursts.burstend{n}));
    end
end

elecs = velecs;

% wave detection starts here
% this is still a little messy and slow :-(
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% note that variable name pburst stands for population burst (= wave)

fprintf(1,'detecting waves...')

stillwaves = 1;
% find the birst burst
[v n] = min(nt);

while max(isfinite(nt)) == 1
    if pburston == 0  % not currently in a wave - start a new wave
        pburst{pburstc}(1) = n; % store channel
        pburstt{pburstc}(1) = v; % store burst time
        if length(bursts.burstend{n})>=eburstc(n)
            pburstsize(pburstc) = bursts.burstsize{n}(eburstc(n)); % record number of spikes
            pburstet{pburstc}(1) = bursts.burstend{n}(eburstc(n)); % record burst end time
            burst_wavenumber{n}(eburstc(n)) = pburstc; % record wave number
            if ops.show_raster==1
            	p=line([v bursts.burstend{n}(eburstc(n))],[n n],'LineWidth',3.5);
            	set(p,'Color',colors(pburstc,:));
            end
        else
            pburstet{pburstc}(1) = NaN;
            pburstsize(pburstc) = NaN;
        end
        eburstc(n) = eburstc(n)+1;
        nt(n) = NaN;
        pburstn = 1;
        pburston = 1;
    else  % continue with current wave

        while (pburston == 1)
            % get indices to previous bursts in the current wave
            prevbursts = max(1,pburstn-ops.nprev):pburstn;

            % get the previous burst locations
            xc = bursts.epos(pburst{pburstc}(prevbursts),1);
            yc = bursts.epos(pburst{pburstc}(prevbursts),2);

            % find all bursts that overlap with the current wave
            working_nt = find(nt<max(pburstet{pburstc}));

            % initialise arrays
            distsdn = zeros(length(nt),1)+1000;  % high values to exclude non-active channels
            %distsd = zeros(length(nt),1)+1;

            % check if we have had previous bursts
            if length(prevbursts)==1
            	% no - just use distances
            	xxc = [repmat(xc',length(working_nt),1) bursts.epos(working_nt,1)];
            	yyc = [repmat(yc',length(working_nt),1) bursts.epos(working_nt,2)];
            	distvec = (sqrt(diff(xxc').^2+diff(yyc').^2))';
            	distsdn(working_nt) = distvec.^2;
            else
            	% yes, get them plus the next bursts to be checked
            	%xxc = [repmat(xc',length(working_nt),1) epos(working_nt,1)];
            	%yyc = [repmat(yc',length(working_nt),1) epos(working_nt,2)];
            	%xc
            	%[repmat(xc(1),ops.nprev-length(xc),1); xc]
                xc = [repmat(xc(1),ops.nprev-length(xc),1); xc];
                yc = [repmat(yc(1),ops.nprev-length(yc),1); yc];

            	xxc = [repmat(xc',length(working_nt),1) bursts.epos(working_nt,1)];
            	yyc = [repmat(yc',length(working_nt),1) bursts.epos(working_nt,2)];
            	distvec = (sqrt(diff(xxc').^2+diff(yyc').^2))';
            	distsdn(working_nt) = var(distvec');
            end

            % find the burst that introduces the smalles variance
            [vsd n] = nanmin(distsdn);
            v = nt(n);

            % check if there is temporal overlap with previous burst
            % has to be done because of the way the arrays are built
            % check also if the variance is smaller than the threshold searchradius
            if nt(n) <= max(pburstet{pburstc}) & min(isnan(nt)) == 0 & vsd < ops.searchradius
            	% if that's all true, then continue the current wave
            	pburstn = pburstn + 1;
            	pburst{pburstc}(pburstn) = n;
            	pburstt{pburstc}(pburstn) = v;
            	if length(bursts.burstend{n})>=eburstc(n)
              	  pburstsize(pburstc) = pburstsize(pburstc) + bursts.burstsize{n}(eburstc(n));
            	  pburstet{pburstc}(pburstn) = bursts.burstend{n}(eburstc(n)); % end time
            	  burst_wavenumber{n}(eburstc(n)) = pburstc;          % record wave number
            	  % plot burst
            	  if ops.show_raster==1
              	    p=line([v bursts.burstend{n}(eburstc(n))],[n n],'LineWidth',3.5);
            	    set(p,'Color',colors(pburstc,:));
            	  end
            	else
              	  pburstet{pburstc}(pburstc) = NaN;
            	end
            	eburstc(n) = eburstc(n)+1;
            	nt(n) = NaN;
            else
            	% no temporal overlap or variance too high, so the wave ends here
            	pburston = 0;

            	%assign next set of bursts on active electrodes that temporally overlap
            	%with detected bursts to the same population burst (wave)
            	foundone = 1;
            	while foundone == 1
              	  foundone = 0;
            	  for n=pburst{pburstc}
              	    if length(bursts.bursttime{n}) >= eburstc(n)
              	      if bursts.bursttime{n}(eburstc(n)) <  max(pburstet{pburstc})
                  		burst_wavenumber{n}(eburstc(n)) = pburstc;
                		eburstc(n) = eburstc(n)+1;
                		foundone = 1;
            	      end
            	    end
            	  end
            	end

            	% get the next set of bursts for the next wave
            	for n=elecs
              	  if length(bursts.bursttime{n}) >= eburstc(n)
              	    nt(n) = bursts.bursttime{n}(eburstc(n));
            	  else
              	    nt(n) = NaN;
            	  end
            	end

            	stillwaves = max(isfinite(nt));
            	[v n] = min(nt);
            end
        end
        pburstc = pburstc + 1;
        pburston = 0;
    end
end

fprintf(1,'done\n')

if ops.show_raster == 1.
    p=line([ops.showtime],[max(bursts.testelecs)+1 max(bursts.testelecs)+1]);
    set(p,'Color','k','LineWidth',1);
    set(gca,'XLim',ops.showtime)
    set(gca,'YLim',[0 max(bursts.testelecs)+5])
    box off
    xlabel('Time/s')
    ylabel('Electrode #')
    hold off
    axis ij
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Wave analysis begins here
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

noCh = length(elecs); % number of channels
rNoCh = length(bursts.bursttime);


% skip wave stats if required
if ops.do_stats == 1

    %% Wave Size Histogram (Electrodes)
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    fprintf(1,'wave sizes\n')
    bsp=subplot(ynplots,xnplots,5);
    startb = 1;
    for i=startb:length(pburst)
        bs(i-startb+1) = length(pburst{i});
    end

    % define bins for histograms
    % and plot histograms
    if ops.cumhists == 0
        bshn = [1:6:(100*ceil(max(bs)/100))];
        [n,v] = hist(bs,bshn);
        n = n/sum(n);
        loglog(v,n,'k.-')
        hold on
        ylabel('P')
        set(gca,'xtick',[1 10 100 1000])
        set(gca,'xticklabel',[1 10 100 1000])
        set(gca,'ytick',[ 0.001 0.01 0.1 1])
        set(gca,'yticklabel',{ '1e-3' '1e-2' '0.1' '1'})
        xlabel('Size (# Electrodes)')
    else
        %bshn = [1:1:100*ceil(max(bs)/100)];
        v = [sort(bs(bs>1))/noCh 1];
        n = [[1:length(bs(bs>1))]/length(bs(bs>1)) 1];
        %plot(v,1-n,'k-')
        loglog(v,1-n,'k-')
        hold on
        ylabel('1-CDF')
        xlabel('Size (fraction electrodes)')
        set(gca,'xlim',[min(v) 1]);
        set(gca,'YLim',[min(1-n) 1]);
        set(gca,'xtick',[0.01 0.1 1]);
        set(gca,'xticklabel',[0.01 0.1 1]);
        set(gca,'ytick',[0.001 0.01 0.1 1]);
        set(gca,'yticklabel',[0.001 0.01 0.1 1]);
    end

    % fit power laws
    if ops.monte_carlo_steps>0
        [alpha(1) xmin(1) ] = plfit(bs,'range',[1.2:0.01:2.1]);
        [alpha(2) xmin(2) ] = plfit(bs(bs>1),'range',[1.2:0.01:2.1]);
        pvalue(1) = plpva(bs,xmin(1),'reps',ops.monte_carlo_steps,'range',[1.2:0.01:2.1],'silent');
        pvalue(2) = plpva(bs(bs>1),xmin(2),'reps',ops.monte_carlo_steps,'range',[1.2:0.01:2.1],'silent');
        % plot histograms
        if ops.cumhists == 1
            loglog(v, (v/v(2)).^(-alpha(1)+1),'r-');
            loglog(v, (v/v(2)).^(-alpha(2)+1),'r-');
            loglog(v, (v/v(2)).^(-0.5),'b-');
        else
            loglog(xv, n(2)/sum(n)*(xv/v(2)).^(-alpha(1)),'r-');
            loglog(xv, n(2)/sum(n)*(xv/v(2)).^(-alpha(2)),'r-');
            loglog(xv, n(2)/sum(n)*(xv/v(2)).^(-1.5),'b-');
        end
    end

    set(gca,'FontSize',12);
    p=get(gca,'Position');
    set(gca,'Position',[p(1)+0.01 p(2) p(3)-0.02 p(4)-0.02]);
    box off


    %% Wave Duration Histogram
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    fprintf(1,'wave duration\n')
    bdp=subplot(ynplots,xnplots,6);
    for i=1:length(pburst)
        bd(i) = max(pburstet{i})-pburstt{i}(1);
    end

    % build and plot histograms
    if ops.cumhists == 0
        bshn2 = [1:2:50];
        [n,v] = hist(bd,bshn2);
        xv = [min(v) max(v)];
        n = n/sum(n);
        loglog(v,n,'k.-')
        hold on
        ylabel('P')
        set(gca,'xtick',[1 10 100])
        set(gca,'xticklabel',[1 10 100])
        set(gca,'ytick',[ 0.001 0.01 0.1 1])
        set(gca,'yticklabel',{ '1e-3' '1e-2' '0.1' '1'})
    else
        v = sort(bd(bs>1));
        n = [1:length(bd(bs>1))]/length(bd(bs>1));
        loglog(v,1-n,'k-')
        %plot(v,1-n,'k-')
        hold on
        ylabel('1-CDF')
        set(gca,'XLim',[min(v) max(v)]);
        set(gca,'YLim',[min(1-n) 1]);
        set(gca,'XLim',[1 100]);
        set(gca,'xtick',[0.01 0.1 1  10 100]);
        set(gca,'xticklabel',[0.01 0.1 1 10 100]);
        set(gca,'ytick',[0.001 0.01 0.1 1]);
        set(gca,'yticklabel',[0.001 0.01 0.1 1]);
    end

    if ops.monte_carlo_steps>0
        % fit power laws
        [alpha(3) xmin(3) ] = plfit(bd);
        [alpha(4) xmin(4) ] = plfit(bd(bs>1));
        pvalue(3) = plpva(bd,xmin(3),'reps',ops.monte_carlo_steps,'silent');
        pvalue(4) = plpva(bd(bs>1),xmin(4),'reps',ops.monte_carlo_steps,4,'silent');
        if ops.cumhists == 1
            loglog(v, (v/v(3)).^(-alpha(3)+1),'r-');
            loglog(v, (v/v(3)).^(-alpha(4)+1),'r-');
            loglog(v, (v/v(3)).^(-1),'b-');
        else
            loglog(xv, n(3)/sum(n)*(xv/v(3)).^(-alpha(3)),'r-');
            loglog(xv, n(3)/sum(n)*(xv/v(3)).^(-alpha(4)),'r-');
            loglog(xv, n(3)/sum(n)*(xv/v(3)).^(-2),'b-');
        end
    end

    xlabel('Duration (s)')
    set(gca,'FontSize',12);
    p=get(gca,'Position');
    set(gca,'Position',[p(1)+0.01 p(2) p(3)-0.02 p(4)-0.02]);
    box off


    %% Burst Size Histogram (Spikes)
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    fprintf(1,'wave sizes (spikes)\n')
    bs2p=subplot(ynplots,xnplots,7);
    fullb = find(pburstsize>0);

    if ops.cumhists == 0
        [n,v] = hist(pburstsize(fullb),100);
        loglog(v,(n/sum(n)),'k.-');
        hold on
        ylabel('P(S)')
        set(gca,'xtick',[10 100 1000])
        set(gca,'xticklabel',[10 100 1000])
        set(gca,'ytick',[ 0.001 0.01 0.1 1])
        set(gca,'yticklabel',{ '1e-3' '1e-2' '0.1' '1'})
    else
        v = sort(pburstsize(fullb));
        n = [1:length(pburstsize(fullb))]/length(pburstsize(fullb));
        loglog(v,1-n,'k-')
        %plot(v,1-n,'k-')
        hold on
        ylabel('1-CDF')
        %set(gca,'YLim',[0.001 1]);
        set(gca,'xtick',[0.01 0.1 1  10 100 1000 10000]);
        set(gca,'xticklabel',[0.01 0.1 1 10 100 1000 10000]);
        set(gca,'ytick',[0.001 0.01 0.1 1]);
        set(gca,'yticklabel',[0.001 0.01 0.1 1]);

    end

    % fit power law
    if ops.monte_carlo_steps>0
        [alpha(5) xmin(5) ] = plfit(pburstsize(fullb),'range',[1.2:0.01:3.0]);
        %pvalue(5) = plpva(pburstsize(fullb),xmin(5),'reps',ops.monte_carlo_steps,'range',[1.2:0.01:3.0],'silent');
        %loglog(xv, n(2)/sum(n)*(xv/v(2)).^(-alpha(5)),'r-');
        alpha
        xmin
        pvalue
    end

    xlabel('S/# Spikes')
    set(gca,'FontSize',12);
    p=get(gca,'Position');
    set(gca,'Position',[p(1)+0.01 p(2) p(3)-0.02 p(4)-0.02]);
    box off

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %% Wave duration vs size
    subplot(ynplots,xnplots,8)
    plot(bd,bs,'k.')
    xlabel('Wave duration (s)')
    ylabel('Size (# Electrodes)')
    set(gca,'FontSize',12);
    p=get(gca,'Position');
    set(gca,'Position',[p(1)+0.01 p(2) p(3)-0.02 p(4)-0.02]);
    box off

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %% IBIs
    fprintf(1,'IBI\n')
    subplot(ynplots,xnplots,9)
    ibis = [];
    for e1 = 1:length(elecs)
        ibis = [ibis diff(bursts.bursttime{e1})];
    end

    if ops.cumhists == 0
        [n,v] = hist(ibis,20);
        plot(v,n/sum(n),'k.-')
        ylabel('P(IBI)')
    else
        v = sort(ibis);
        n = [1:length(ibis)]/length(ibis);
        plot(v,n,'k-')
        hold on
        ylabel('CDF')
    end

    xlabel('IBI (s)')
    set(gca,'FontSize',12);
    p=get(gca,'Position');
    set(gca,'Position',[p(1)+0.01 p(2) p(3)-0.02 p(4)-0.02]);
    box off

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %% Burst durations
    subplot(ynplots,xnplots,10)
    if ops.cumhists == 0
        [n,v] = hist(bdur,20);
        plot(v,n/sum(n),'k.-')
        ylabel('P(Duration)')
    else
        v = sort(bdur);
        n = [1:length(bdur)]/length(bdur);
        plot(v,n,'k-')
        hold on
        ylabel('CDF')
    end
    xlabel('Burst duration (s)')
    set(gca,'FontSize',12);
    p=get(gca,'Position');
    set(gca,'Position',[p(1)+0.01 p(2) p(3)-0.02 p(4)-0.02]);
    box off


    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    %% report some numbers
    subplot(ynplots,xnplots,11)
    lineh = 0.12;
    fontSize = 14;

    text(0,1,[num2str(length(bs)),' waves; '], 'FontSize',fontSize)
    text(0.6,1,[num2str(length(bs(bs>1))),' waves (ex 1)'], 'FontSize',fontSize)
    text(0,0.95-lineh,['Number of APS channels = ',num2str(noCh),'/',num2str(rNoCh)],'FontSize',fontSize)

    text(0,0.95-lineh*2,['Time of last burst = ',num2str(lastburstend,3),'s'],'FontSize',fontSize)

    text(0,0.95-lineh*3,['Mean IBI = ',num2str(mean(ibis),3),'\pm', num2str(std(ibis),3),'s'],'FontSize',fontSize);
    text(1.2,0.95-lineh*3,['Quartiles: ',num2str(prctile(ibis, [25 50 75]),3)],'FontSize',fontSize);

    text(0,0.95-lineh*4,['Mean burst duration = ',num2str(mean(bdur),3),'\pm',num2str(std(bdur),3),'s'],'FontSize',fontSize);
    text(1.2,0.95-lineh*4,['Quartiles: ',num2str(prctile(bdur, [25 50 75]),3)],'FontSize',fontSize);

    % number of channels
    text(0,0.95-lineh*5,['Mean wave size = ',num2str(mean(bs),3),'\pm',num2str(std(bs),3),'ch'],'FontSize',fontSize);
    text(1.2,0.95-lineh*5,['Quartiles: ',num2str(prctile(bs, [25 50 75]),3)],'FontSize',fontSize);

    text(0,0.95-lineh*6,['Mean wave size (ex 1) = ',num2str(mean(bs(bs>1)),3),'\pm',num2str(std(bs(bs>1)),3),'ch'],'FontSize',fontSize);
    text(1.2,0.95-lineh*6,['Quartiles: ',num2str(prctile(bs(bs>1), [25 50 75]),3)],'FontSize',fontSize);

    % fraction channels
    text(0,0.95-lineh*7,['Mean wave size = ',num2str(mean(bs/noCh),3),'\pm',num2str(std(bs/noCh),3)],'FontSize',fontSize);
    text(1.2,0.95-lineh*7,['Quartiles: ',num2str(prctile(bs/noCh, [25 50 75]),3)],'FontSize',fontSize);

    text(0,0.95-lineh*8,['Mean wave size (ex 1) = ',num2str(mean(bs(bs>1)/noCh),3),'\pm',num2str(std(bs(bs>1)/noCh),3)],'FontSize',fontSize);
    text(1.2,0.95-lineh*8,['Quartiles: ',num2str(prctile(bs(bs>1)/noCh, [25 50 75]),3)],'FontSize',fontSize);


    text(0,0.95-lineh*9,['Mean wave dur. = ',num2str(mean(bd),3),'\pm',num2str(std(bd),3),'s'],'FontSize',fontSize);
    text(1.2,0.95-lineh*9,['Quartiles: ',num2str(prctile(bd, [25 50 75]),3)],'FontSize',fontSize);

    text(0,0.95-lineh*10,['Mean wave dur. (ex 1) = ',num2str(mean(bd(bs>1)),3),'\pm',num2str(std(bd(bs>1)),3),'s'],'FontSize',fontSize);
    text(1.2,0.95-lineh*10,['Quartiles: ',num2str(prctile(bd(bs>1), [25 50 75]),3)],'FontSize',fontSize);

    set(gca,'FontSize',fontSize);
    axis off

end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% save main plot/data
if(ops.save_data == 1)
    fprintf(1,'saving data\n')
    if (ops.do_stats)
        if (ops.monte_carlo_steps > 0)
            %         save([file,'_waves.mat'],'bdur','ibis','alpha','pvalue','xmin','bs','bd','pburst','pburstt','pburstet','epos');
            % wavesOutput
            waves.bdur = bdur;
            waves.ibis = ibis;
            waves.alpha = alpha;
            waves.pvalue = pvalue;
            waves.xmin = xmin;
            waves.bs = bs;
            waves.bd = bd;
            waves.pburst = pburst;
            waves.pburstt = pburstt;
            waves.pburstet = pburstet;
            waves.epos = bursts.epos;

            waveEx.waves = waves;
            save([filepathStruct '.mat'], 'waveEx');
        else
            %         save([file,'_waves.mat'],'bdur','ibis','bs','bd','pburst','pburstt','pburstet','epos');
            % wavesOutput
            waves.bdur = bdur;
            waves.ibis = ibis;
            waves.bs = bs;
            waves.bd = bd;
            waves.pburst = pburst;
            waves.pburstt = pburstt;
            waves.pburstet = pburstet;
            waves.epos = bursts.epos;

            waveEx.waves = waves;
            save([filepathStruct '.mat'], 'waveEx');

        end
    else
        %     save([file,'_waves.mat'], 'pburst','pburstt','pburstet','epos');
        % wavesOutput
        waves.pburst = pburst;
        waves.pburstt = pburstt;
        waves.pburstet = pburstet;
        waves.epos = bursts.epos;

        waveEx.waves = waves;
        save([filepathStruct '.mat'], 'waveEx');
    end
end

if((ops.show_raster == 1 | ops.do_stats == 1) & ops.save_figs == 1)
    fprintf(1,'saving summary graph\n')
    %   print(h1,'-dpsc2','-r300',[file,'_waves.ps']);
    %   print(h1,'-dpng','-r150',[file,'_waves.png']);

    pause(0.001);
    tightfig;
    exportgraphics(h1,[rootFilepath,'_waves.eps'], "Resolution",300, 'ContentType','vector');

    % much faster way to save png
    dpm = fix((300/2.54) * 100);% 300DPI = dpm Dots Per Meter

    % get figure as image
    figCDat = getframe(h1);
    figCDat = figCDat.cdata;

    imwrite(figCDat,[rootFilepath,'_waves.png'], 'png', ...
        'ResolutionUnit', 'meter', ...
        'XResolution', dpm, ...
        'YResolution', dpm);
    %     exportgraphics(h1,[file,'_waves.png'], "Resolution",150);
end


%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% do a plot of 6x6 waves
if ops.show36 == 1

    fprintf(1,'preparing x-y plots...')

    h2 = figure(2);
    clf
    fs = [18 19.5];
    fs = [14 14]*1.1;
    set(h2, 'PaperOrientation','portrait');
    set(h2, 'PaperType','a4');
    set(h2,'PaperUnits','centimeters');
    set(h2,'Units','centimeters');
    p = get(h2,'Position');
    p = [p(1:2) fs];
    p(2) = p(2)-6; % HACK to fix figure screen position
    set(h2,'PaperSize',fs)
    set(h2,'PaperPosition',[0 0 fs])
    set(h2,'Position',p);
    set(gcf, 'color', 'white');
    %set(gcf, 'InvertHardCopy', 'off');
    %set(gcf, 'color', 'black');
    set(gcf, 'InvertHardCopy', 'off');

    set(h2,'Units','normalized');
    set(h2,'PaperUnits','normalized');

    start = 0;
    ii = 1;

    wss=cellfun(@min,pburstt);
    start = find(wss > ops.showtime(1));
    i = start(1);

    % draw all electrodes as patches
    while ii <= 36 & length(pburst)>i %& pburstt{i+1}(1)<=max(ops.showtime),
        %subplot(6,6,ii-start)
        phandle = axes;
        set(gca,'Position',[mod(ii-1,6)*1/6 5/6-(ceil(ii/6)-1)*1/6 1/6 1/6])

        %patch([1 1 68 68],[1 68 68 1],[1 1 1])
        col = [0.8 0.8 0.8];
        %col = [0.25 0.25 0.25];
        patch([1 1 68 68],[1 68 68 1],col)
        %patch([1 1 68 68],[1 68 68 1],[0 0 0])

        % prepare and clear all patches
        col = [0.8 0.8 0.8];
        col = [1 1 1];
        %col = [0 0 0];
        for enum = 1:length(bursts.testelecs) %elecs,
            phandle(enum) = patch([bursts.epos(enum,1) bursts.epos(enum,1)+1 bursts.epos(enum,1)+1 bursts.epos(enum,1)], [bursts.epos(enum,2) bursts.epos(enum,2) bursts.epos(enum,2)+1 bursts.epos(enum,2)+1], [0 0 0 0]);
            set(phandle(enum),'FaceColor',col,'EdgeColor','none')
        end

        i=i+1;
        % only plot waves larger than minwavesize
        while length(pburst)>i & length(pburst{i}) < ops.minwavesize
            i=i+1;
        end

        tmp = pburstt{i} -pburstt{i}(1);
        if length(tmp)>1
            if max(tmp) ~= tmp(1)
            	tmp = tmp / max(tmp);
            end
        else
            tmp = 1;
        end
        tmp = 1-tmp;

        % set colour according to burst time
        for j=1:length(pburst{i})
            col = [tmp(j) 0 1-tmp(j) ];
            %col = [tmp(j) tmp(j) tmp(j) ];
            %col = ((1-tmp(j))*0.75+0.25)*colors(i,:);
            col = ((1-tmp(j))*0.75)*colors(i,:);
            %col = colors(i,:);
            set(phandle(pburst{i}(j)),'FaceColor',col,'EdgeColor','none')
        end

        set(gca,'xlim',[-1 68])
        set(gca,'ylim',[-1 68])

        % format plots
        axis square
        %title(num2str(ii))
        %axis ij
        axis off

        ii = ii + 1;
    end

    refresh
    fprintf(1,'done\n')

    if(ops.save_figs == 1)
        fprintf(1,'saving x-y plot\n')
        % dot not save postscript - files are too large
        %print(h2,'-dpsc2','-r300',[file,'_30waves.ps'])

        exportgraphics(h2,[rootFilepath,'_waves36.eps'], "Resolution",300, 'ContentType','vector');

        % %% much faster way to save png
        dpm = fix((300/2.54) * 100);% 300DPI = dpm Dots Per Meter

        % get figure as image
        figCDat = getframe(h2);
        figCDat = figCDat.cdata;

        imwrite(figCDat,[rootFilepath,'_waves36.png'], 'png', ...
            'ResolutionUnit', 'meter', ...
            'XResolution', dpm, ...
            'YResolution', dpm);
        %     exportgraphics(h2,[file,'_30waves.png'],"Resolution",300);
    end
end
%% movie creation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

if ops.show_movie == 0
    return
end

fprintf('creating movie frame: ');
hm = figure; %('visible','off');
clf
fs = [11 11];
set(hm, 'PaperOrientation','portrait');
set(hm, 'PaperType','a4');
set(hm,'PaperUnits','centimeters');
set(hm,'Units','centimeters');
p = get(hm,'Position');
p = [p(1:2) fs];
set(hm,'PaperSize',fs)
set(hm,'PaperPosition',[0 0 fs])
set(hm,'Position',p)
set(hm, 'color', 'black');
set(hm,'renderer','zbuffer'); % need this for windows 7

%wss=cellfun(@min,pburstt);
%start = find(wss >= ops.showtime(1))
%i = start(1);

burstnum = zeros(max(elecs),1)+1;
activity = zeros(max(elecs),1);

aviFileName = [rootFilepath,'_waves.avi'];
framesPerSec = 8;

if ops.save_figs == 1
    aviobj = VideoWriter(aviFileName);
    aviobj.FrameRate = framesPerSec;
    open(aviobj);

    %   try
    %     aviobj = avifile(aviFileName,'fps',framesPerSec,'compression','cinepak','videoname',aviFileName);
    %   catch
    %     %aviobj = avifile(aviFileName,'fps',framesPerSec,'videoname',aviFileName);
    %     aviobj = avifile(aviFileName,'fps',framesPerSec,'videoname','matlabsucks');
    %   end
end

movie_windowsize = 1; % in seconds
movie_windows = ops.showtime(1):movie_windowsize:ops.showtime(2);
movie_nums = ceil(ops.showtime(1)/movie_windowsize)+1:ceil(ops.showtime(2)/movie_windowsize)+1;
movie_tau = 0.1; % decay time (used 0.2 before)
movie_ms = 4;  % marker size

fill([1 1 66 66],[1 66 66 1],[0.5 0.5 0.5])
hold on
for enum = 1:length(bursts.testelecs)
    col(enum,:) = [0 0 0];
    phandle(enum) = patch([bursts.epos(enum,1) bursts.epos(enum,1)+1 bursts.epos(enum,1)+1 bursts.epos(enum,1)], [bursts.epos(enum,2) bursts.epos(enum,2) bursts.epos(enum,2)+1 bursts.epos(enum,2)+1], [0 0 0 0]);
    set(phandle(enum),'FaceColor',col(enum,:),'EdgeColor','none')
    %  hold on
end

for enum = elecs
    %t = find(bursttime{enum}>=ops.showtime(1));
    %if ~isempty(t),
    %  burststarts_w{enum} = [ceil((bursttime{enum}-bursttime{enum}(t(1)))/movie_windowsize)];
    %  burstnum(enum) = t(1);
    %else
    %  burststarts_w{enum} = [ceil((bursttime{enum})/movie_windowsize)];
    %  burstnum(enum) = 1;
    %end
    %  burststarts_w{enum} = ops.showtime(2)/movie_windowsize+1;
    %end
    %burstends_w{enum} = ceil(burstend{enum}(t)/movie_windowsize)+1;
    t = [ceil((bursts.bursttime{enum})/movie_windowsize)];
    tt = find(t>movie_nums(1));
    if ~isempty(tt)
        %burststarts_w{enum} = t(tt);
        burstnum(enum) = tt(1);
        %else
        %burststarts_w{enum} = [1];
    end
    burststarts_w{enum} = [ceil((bursts.bursttime{enum})/movie_windowsize)];
end

set(gca,'xlim',[1 66]);
set(gca,'ylim',[1 66]);
text_h = text(1,-2, ['0s']);
set(text_h,'Color','w');
axis square
%axis ij
axis off
refresh

for t = movie_nums
    %for t = 1:length(movie_windows),
    for enum = elecs
        % leaky integrate activity
        activity(enum) = activity(enum) - movie_tau*activity(enum);
        if burststarts_w{enum}(burstnum(enum)) == t
            activity(enum) = 1;
            % the max here traps a possible zero index
            col(enum,:) = colors(max(1,burst_wavenumber{enum}(burstnum(enum))),:);
            burstnum(enum) = min(length(burststarts_w{enum}),burstnum(enum)+1);
        end
        tmp = activity(enum);
        set(phandle(enum),'FaceColor',col(enum,:)*tmp,'EdgeColor','none');
    end
    set(text_h,'string', [num2str(t*movie_windowsize),'s']);
    if ops.save_figs == 1
        writeVideo(aviobj,getframe(hm));
        %     aviobj = addframe(aviobj,getframe(hm));
    else
        refresh
        %     pause(0.02)
    end
end


if ops.save_figs == 1
    fprintf('...done, saving movie\n');
    close(aviobj);
    %   close(hm)
else
    fprintf('...done\n');
end

close all
clear
return
